[manifest]
version = "1.0.0"
dump_lua = true
priority = 0

# Leak
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''-- TARGET: effects before scoring starts'''
position = 'before'
payload = '''
if G.GAME.payasaka_leak_active then
	G.E_MANAGER:add_event(Event({func = function()
		for i = 1, #scoring_hand do
			G.E_MANAGER:add_event(Event({func = function() scoring_hand[i]:juice_up(); return true end })) 
			ease_dollars(-G.GAME.payasaka_leak_active)
			delay(0.23)
		end
	return true end })) 
end
'''
match_indent = true

# Eclipse
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''-- TARGET: effects before scoring starts'''
position = 'before'
payload = '''
local mto_big = to_big or function(a) return a end
G.GAME.payasaka_last_hand_name = nil
if G.GAME.payasaka_decay_active and G.GAME.payasaka_decay_active > 0 and mto_big(G.GAME.hands[text].level) > mto_big(1) then
	G.GAME.payasaka_last_hand_name = text
	G.GAME.payasaka_last_hand_level = G.GAME.hands[text].level
	level_up_hand(nil, text, nil, -math.max(1, G.GAME.hands[text].level - (G.GAME.hands[text].level/G.GAME.payasaka_decay_active)))
end
'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''-- context.after calculations'''
position = 'before'
payload = '''
if G.GAME.payasaka_decay_active and G.GAME.payasaka_decay_active > 0 and G.GAME.payasaka_last_hand_name then
	G.E_MANAGER:add_event(Event{
		func = function()
			local hand = G.GAME.hands[G.GAME.payasaka_last_hand_name]
			hand.level = G.GAME.payasaka_last_hand_level
    		hand.mult = math.max(hand.s_mult + hand.l_mult*(hand.level - 1), 1)
    		hand.chips = math.max(hand.s_chips + hand.l_chips*(hand.level - 1), 0)
			return true
		end
	})
end
'''
match_indent = true

# Elusive
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''draw_card(G.deck,G.hand, i*100/hand_space,'up', true)'''
position = 'at'
payload = '''
draw_card(G.deck,G.hand, i*100/hand_space,'up', true, nil, nil, nil, i <= (G.GAME.payasaka_elusive_cards or 0))
'''
match_indent = true

# This is a very stupid patch.
# I shouldn't need to do this but doing this some other way requires me to tinker more and ionlikedat
# Thunk pls fix
[[patches]]
[patches.pattern]
target = 'cardarea.lua'
pattern = '''local stay_flipped = G.GAME and G.GAME.blind and G.GAME.blind:stay_flipped(self, card, area)'''
position = 'at'
payload = '''
stay_flipped = stay_flipped or (G.GAME and G.GAME.blind and G.GAME.blind:stay_flipped(self, card, area))
'''
match_indent = true

# Stunted
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''-- TARGET: effects before scoring starts'''
position = 'after'
payload = '''
if G.GAME.payasaka_stunted_active then
	for i = 1, #G.play.cards do
		local card = G.play.cards[i]
		if pseudorandom('ham_slice') < (G.GAME.probabilities.normal or 1)/G.GAME.payasaka_stunted_chance and card.ability.set == 'Enhanced' then
			card.ability.set = 'Default'
			card.ability.payasaka_old_effect = card.ability.effect
			card.ability.payasaka_old_ee = card.ability.extra_enhancement
			card.ability.effect = nil
			card.ability.extra_enhancement = false
			card.ability.payasaka_stunted = true
			card_eval_status_text(card, 'extra', nil, nil, nil,
						{ message = "Stunted!" })
		end
	end
end
'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''-- context.after calculations'''
position = 'after'
payload = '''
if G.GAME.payasaka_stunted_active then
	for i = 1, #G.play.cards do
		local card = G.play.cards[i]
		if card.ability.payasaka_stunted then
			card.ability.set = 'Enhanced'
			card.ability.effect = card.ability.effect
			card.ability.extra_enhancement = card.ability.payasaka_old_ee
			card.ability.payasaka_stunted = nil
			card.ability.payasaka_old_effect = nil
			card.ability.payasaka_old_ee = nil
			card_eval_status_text(card, 'extra', nil, nil, nil,
						{ message = "Reverted!" })
		end
	end
end
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = "          G.GAME.stake > 1 and {"
position = "before"
payload = '''
{
	label = G.GAME.risk_cards_risks and #G.GAME.risk_cards_risks > 0 and localize('b_risk_cards') or nil, 
	tab_definition_function = G.GAME.risk_cards_risks and #G.GAME.risk_cards_risks > 0 and G.UIDEF.current_risks or nil,
},'''
match_indent = true

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''
if card.ability.set == 'Booster' then
      G.CONTROLLER.locks.use = false
      G.TAROT_INTERRUPT = nil
'''
position = "at"
payload = '''
if card.ability.set == 'Booster' or (card.config.center.fake_booster and not select_to) then
      G.CONTROLLER.locks.use = false
      G.TAROT_INTERRUPT = nil
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''
local select_to = card.area == G.pack_cards and booster_obj and booster_obj.select_card and card:selectable_from_pack(booster_obj)
'''
position = "after"
payload = '''
if card.config.center.pta_selectable and card.area == G.pack_cards then select_to = "consumeables" end
'''
match_indent = true

[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''draw_card(G.play,G.discard, it*100/play_count,'down', false, v)'''
position = 'at'
payload = '''
if G.GAME.payasaka_prelude then
	v:set_debuff(true)
	draw_card(G.play,G.deck, it*100/play_count,'down', false, v)
else
	draw_card(G.play,G.discard, it*100/play_count,'down', false, v)
end
'''
match_indent = true